import {
	IInsightFacade,
	InsightDataset,
	InsightDatasetKind,
	InsightError,
	InsightResult,
	NotFoundError,
	ResultTooLargeError,
} from "./IInsightFacade";
import JSZip from "jszip";
import * as fs from "fs-extra";
import * as p5 from "parse5";
import * as http from "node:http";
import Decimal from "decimal.js";

/**
 * This is the main programmatic entry point for the project.
 * Method documentation is in IInsightFacade
 *
 */

export interface CourseSection {
	uuid: string;
	id: string;
	title: string;
	instructor: string;
	dept: string;
	year: number;
	avg: number;
	pass: number;
	fail: number;
	audit: number;
}

export interface RoomSection {
	fullname: string;
	shortname: string;
	number: string;
	name: string;
	address: string;
	lat: number;
	lon: number;
	seats: number;
	type: string;
	furniture: string;
	href: string;
}

export interface Building {
	fullname: string;
	shortname: string;
	address: string;
	href: string;
}

export interface GeoResponse {
	lat?: number;
	lon?: number;
	error?: string;
}

export default class InsightFacade implements IInsightFacade {
	private datasets: InsightDataset[] = [];
	//start of code generated by ChatGPT
	private readonly cashDone: Promise<void>;
	// end of code generated by chatGPT
	// start of code generated by ChatGPT
	constructor() {
		this.cashDone = this.cachingProcess();
	}
	// end of code generated by ChatGPT
	private async cachingProcess(): Promise<void> {
		if (await fs.pathExists("./data")) {
			const files = await fs.readdir("./data");
			const metaPromises = files.map(async (file) => {
				const metaData = await fs.readJSON(`./data/${file}`);
				const datasetInfo: InsightDataset = { id: metaData.id, kind: metaData.kind, numRows: metaData.numRows };
				this.datasets.push(datasetInfo);
			});
			await Promise.all(metaPromises);
		}
	}

	private async unzipCourseData(id: string, content: string, kind: InsightDatasetKind): Promise<void> {
		let numRows = 0;
		const setYear: number = 1900;
		const courseSections: CourseSection[] = [];
		const filenames: string[] = [];

		let zip: JSZip;

		try {
			zip = await JSZip.loadAsync(content, { base64: true });
		} catch (error) {
			throw new InsightError(String(error));
		}
		const folder = zip.folder("courses");
		const filePath = `data/${id}.json`;

		// check for folder root is not courses
		if (!folder) {
			throw new InsightError();
		}
		//only treat for file end with .Json
		folder.forEach(function (filename) {
			filenames.push(filename);
		});
		// start of code generated by ChatGPT
		const filePromises = filenames.map(async (path) => {
			const fileObject = folder.file(path);
			if (!fileObject) {
				return;
			}
			let fileData;
			try {
				fileData = await fileObject.async("string");
			} catch (err) {
				throw new InsightError(String(err));
			}
			// end of code generated by ChatGPT
			// start of code generated by ChatGPT
			const isValidJson = (str: string): boolean => {
				try {
					JSON.parse(str);
					return true;
				} catch {
					return false;
				}
			};
			//end of code generated by ChatGPT
			let rawData;
			if (!isValidJson(fileData)) {
				return;
			} else {
				rawData = JSON.parse(fileData);
			}

			if (!rawData.result) {
				return;
			}
			rawData.result.forEach((record: any) => {
				if (
					record.id === undefined ||
					record.Course === undefined ||
					record.Title === undefined ||
					record.Professor === undefined ||
					record.Subject === undefined ||
					record.Year === undefined ||
					record.Avg === undefined ||
					record.Pass === undefined ||
					record.Fail === undefined ||
					record.Audit === undefined
				) {
					return;
				}

				const newSections: CourseSection = {
					uuid: record.id.toString(),
					id: record.Course,
					title: record.Title,
					instructor: record.Professor,
					dept: record.Subject,
					year: record.Section === "overall" ? setYear : Number(record.Year),
					avg: record.Avg,
					pass: record.Pass,
					fail: record.Fail,
					audit: record.Audit,
				};
				courseSections.push(newSections);
				numRows++;
			});
		});
		// start of code generated by ChatGPT
		await Promise.all(filePromises);
		// end of code generated by ChatGPT
		if (numRows === 0) {
			throw new InsightError();
		}
		const metaData: InsightDataset = { id, kind, numRows };
		this.datasets.push(metaData);
		const dataSet = { id, kind, numRows, courseSections };
		// start of code generated by ChatGPT
		await fs.mkdir("data", { recursive: true });
		// end of code generated by ChatGPT
		await fs.writeFile(filePath, JSON.stringify(dataSet));
	}

	private async unzipRoomData(id: string, content: string, kind: InsightDatasetKind): Promise<void> {
		const filePath = `data/${id}.json`;
		let zip: JSZip;
		try {
			zip = await JSZip.loadAsync(content, { base64: true });
		} catch (error) {
			throw new InsightError(String(error));
		}
		const indexFile = zip.file("index.htm");
		if (!indexFile) {
			throw new InsightError();
		}
		let indexData;
		try {
			indexData = await indexFile.async("string");
		} catch (err) {
			throw new InsightError(String(err));
		}
		const indexJson = p5.parse(indexData);
		const table = await this.findBuildingTableNode(indexJson);
		const buildings = await this.findBuildings(table);
		const allRooms: RoomSection[] = await this.readBuildings(buildings, zip);
		const numRows: number = allRooms.length;
		if (numRows === 0) {
			throw new InsightError();
		}
		const metaData: InsightDataset = { id, kind, numRows };
		this.datasets.push(metaData);
		const dataSet = { id, kind, numRows, allRooms };
		await fs.mkdir("data", { recursive: true });
		await fs.writeFile(filePath, JSON.stringify(dataSet));
	}

	private async findBuildingTableNode(jsonValue: any): Promise<any> {
		const requiredClass = new Set([
			"views-field views-field-field-building-code",
			"views-field views-field-title",
			"views-field views-field-field-building-address",
		]);
		const columnCorrect: string[] = [];
		if (jsonValue.nodeName === "table") {
			for (const node of jsonValue.childNodes) {
				if (node.nodeName === "thead") {
					for (const node2 of node.childNodes) {
						if (node2.nodeName === "tr") {
							for (const node3 of node2.childNodes) {
								if (node3.nodeName === "th") {
									for (const attr of node3.attrs) {
										if (requiredClass.has(attr.value) && !columnCorrect.includes(attr.value)) {
											columnCorrect.push(attr.value);
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (columnCorrect.length === 3) {
			return jsonValue;
		}
		// start of code generated by ChatGPT
		if (jsonValue.childNodes && jsonValue.childNodes.length > 0) {
			return this.buildingNodeRecursive(jsonValue.childNodes, 0);
		}
		return null;
		// end of code generated by ChatGPT
	}
	// start of code generated by ChatGPT
	private async buildingNodeRecursive(nodes: any[], index: number): Promise<any> {
		if (index >= nodes.length) {
			return null;
		}
		const table = await this.findBuildingTableNode(nodes[index]);
		if (table) {
			return table;
		}
		return this.buildingNodeRecursive(nodes, index + 1);
	}
	// end of code generated by ChatGPT

	private async findBuildings(table: any): Promise<Building[]> {
		const buildings: Building[] = [];
		for (const node of table.childNodes) {
			if (node.nodeName === "tbody") {
				for (const node1 of node.childNodes) {
					if (node1.nodeName === "tr") {
						// start of code generated by ChatGPT
						let fullname: string | undefined = undefined;
						let shortname: string | undefined = undefined;
						let address: string | undefined = undefined;
						let href: string | undefined = undefined;
						// end of code generated by ChatGPT
						for (const node2 of node1.childNodes) {
							if (node2.nodeName === "td") {
								for (const attr of node2.attrs) {
									if (attr.value === "views-field views-field-field-building-code") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "#text") {
												// start of code generated by ChatGPT
												shortname = node3.value.trim();
												// end of code generated by ChatGPT
											}
										}
									}
									if (attr.value === "views-field views-field-title") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "a") {
												for (const attr1 of node3.attrs) {
													if (attr1.name === "href") {
														// start of code generated by ChatGPT
														href = attr1.value.replace(/^\.\//, "");
														// end of code generated by ChatGPT
													}
												}
												for (const node4 of node3.childNodes) {
													if (node4.nodeName === "#text") {
														fullname = node4.value;
													}
												}
											}
										}
									}
									if (attr.value === "views-field views-field-field-building-address") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "#text") {
												address = node3.value.trim();
											}
										}
									}
								}
							}
						}
						if (fullname !== undefined && shortname !== undefined && address !== undefined && href !== undefined) {
							const newBuilding: Building = { fullname, shortname, address, href };
							buildings.push(newBuilding);
						}
					}
				}
			}
		}
		return buildings;
	}

	private async readBuildings(buildings: Building[], zip: JSZip): Promise<RoomSection[]> {
		const allRooms: RoomSection[] = [];
		const buildingPromises = buildings.map(async (building: Building) => {
			let roomJson;
			let roomData;
			const roomObject = zip.file(building.href);
			if (!roomObject) {
				return;
			} else {
				roomData = await roomObject.async("string");
				roomJson = p5.parse(roomData);
				const rooms = await this.readRooms(roomJson, building.fullname, building.shortname, building.address);
				// start of code generated by ChatGPT
				allRooms.push(...rooms);
				// end of code generated by ChatGPT
			}
		});
		await Promise.all(buildingPromises);
		return allRooms;
	}

	private async readRooms(roomJson: any, fullname: string, shortname: string, address: string): Promise<RoomSection[]> {
		const table = await this.findRoomTableNode(roomJson);
		if (table) {
			return await this.findRooms(table, fullname, shortname, address);
		} else {
			return [];
		}
	}

	private async findRoomTableNode(roomJson: any): Promise<any> {
		const requiredClass = new Set([
			"views-field views-field-field-room-number",
			"views-field views-field-field-room-capacity",
			"views-field views-field-field-room-furniture",
			"views-field views-field-field-room-type",
		]);
		const columnCorrect: string[] = [];
		if (roomJson.nodeName === "table") {
			for (const node of roomJson.childNodes) {
				if (node.nodeName === "thead") {
					for (const node2 of node.childNodes) {
						if (node2.nodeName === "tr") {
							for (const node3 of node2.childNodes) {
								if (node3.nodeName === "th") {
									for (const attr of node3.attrs) {
										if (requiredClass.has(attr.value)) {
											if (requiredClass.has(attr.value) && !columnCorrect.includes(attr.value)) {
												columnCorrect.push(attr.value);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (columnCorrect.length === 4) {
			return roomJson;
		}
		if (roomJson.childNodes && roomJson.childNodes.length > 0) {
			return this.roomNodeRecursive(roomJson.childNodes, 0);
		}
		return null;
	}

	private async roomNodeRecursive(nodes: any[], index: number): Promise<any> {
		if (index >= nodes.length) {
			return null;
		}
		const table = await this.findRoomTableNode(nodes[index]);
		if (table) {
			return table;
		}
		return this.roomNodeRecursive(nodes, index + 1);
	}

	private async findRooms(table: any, fullname: string, shortname: string, address: string): Promise<RoomSection[]> {
		const rooms: RoomSection[] = [];
		const geoData = await this.getGeoData(address);
		let lat: number | undefined = undefined;
		let lon: number | undefined = undefined;
		if (geoData.lat !== undefined && geoData.lon !== undefined && geoData.error === undefined) {
			lat = geoData.lat;
			lon = geoData.lon;
		} else {
			return rooms;
		}
		for (const node of table.childNodes) {
			if (node.nodeName === "tbody") {
				for (const node1 of node.childNodes) {
					if (node1.nodeName === "tr") {
						let number: string | undefined = undefined;
						let name: string | undefined = undefined;
						let seats: number | undefined = undefined;
						let type: string | undefined = undefined;
						let furniture: string | undefined = undefined;
						let href: string | undefined = undefined;
						for (const node2 of node1.childNodes) {
							if (node2.nodeName === "td") {
								for (const attr of node2.attrs) {
									if (attr.value === "views-field views-field-field-room-number") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "a") {
												for (const attr1 of node3.attrs) {
													if (attr1.name === "href") {
														href = attr1.value;
													}
												}
												for (const node4 of node3.childNodes) {
													if (node4.nodeName === "#text") {
														number = node4.value;
														name = shortname + "_" + number;
													}
												}
											}
										}
									}
									if (attr.value === "views-field views-field-field-room-capacity") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "#text") {
												seats = Number(node3.value.trim());
											}
										}
									}
									if (attr.value === "views-field views-field-field-room-furniture") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "#text") {
												furniture = node3.value.trim();
											}
										}
									}
									if (attr.value === "views-field views-field-field-room-type") {
										for (const node3 of node2.childNodes) {
											if (node3.nodeName === "#text") {
												type = node3.value.trim();
											}
										}
									}
								}
							}
						}
						if (
							number !== undefined &&
							name !== undefined &&
							lat !== undefined &&
							lon !== undefined &&
							seats !== undefined &&
							type !== undefined &&
							furniture !== undefined &&
							href !== undefined
						) {
							const room: RoomSection = {
								fullname,
								shortname,
								number,
								name,
								address,
								lat,
								lon,
								seats,
								type,
								furniture,
								href,
							};
							rooms.push(room);
						}
					}
				}
			}
		}
		return rooms;
	}

	// start of code generated by ChatGPT
	private async getGeoData(address: string): Promise<any> {
		const encoded = encodeURIComponent(address);
		const url = `http://cs310.students.cs.ubc.ca:11316/api/v1/project_team183/${encoded}`;
		return new Promise((resolve) => {
			http
				.get(url, (res) => {
					if (res.statusCode !== 200) {
						// Non-200 => skip
						return resolve(undefined);
					}
					let rawData = "";
					res.on("data", (chunk) => {
						rawData += chunk;
					});
					res.on("end", () => {
						try {
							const parsed: GeoResponse = JSON.parse(rawData);
							return resolve(parsed);
						} catch {
							return resolve(undefined);
						}
					});
				})
				.on("error", () => {
					// Network or other error
					return resolve(undefined);
				});
		});
	}
	// end of code generated by ChatGPT

	public async addDataset(id: string, content: string, kind: InsightDatasetKind): Promise<string[]> {
		// check for syntax in id
		await this.cashDone;
		if (id === "" || id.trim().length === 0 || id.includes("_")) {
			throw new InsightError();
		}

		//check for same id or not.
		if (this.datasets.some((dataset) => dataset.id === id)) {
			throw new InsightError();
		}
		//check for InsightDatasetKind
		if (kind === InsightDatasetKind.Sections) {
			await this.unzipCourseData(id, content, kind);
		} else if (kind === InsightDatasetKind.Rooms) {
			await this.unzipRoomData(id, content, kind);
		} else {
			throw new InsightError();
		}

		return this.datasets.map((dataset) => dataset.id);
	}

	public async removeDataset(id: string): Promise<string> {
		await this.cashDone;
		const filePath = `data/${id}.json`;
		if (id === "" || id.trim().length === 0 || id.includes("_")) {
			throw new InsightError();
		}
		if (!this.datasets.some((dataset) => dataset.id === id)) {
			throw new NotFoundError();
		}
		await fs.remove(filePath);
		this.datasets = this.datasets.filter((dataset) => dataset.id !== id);
		return id;
	}

	private handleWhere(
		where: any,
		dataset: CourseSection[] | RoomSection[],
		datasetType: "sections" | "rooms"
	): CourseSection[] | RoomSection[] {
		if (Object.keys(where).length === 0) {
			return dataset;
		}

		// GT,LT,EQ
		if (where.GT || where.LT || where.EQ) {
			const comparatorKeys = ["GT", "LT", "EQ", "IS"].filter((key) => where[key]);
			if (comparatorKeys.length > 1) {
				throw new InsightError("Cant have more than one comparator");
			}
			return this.handleComparator(where, dataset, datasetType);
		}
		// wildcard is
		if (where.IS) {
			return this.handleStringComparator(where, dataset, datasetType);
		}
		// logical comparator
		if (where.AND || where.OR) {
			return this.handleLogic(where, dataset, datasetType);
		}
		//
		// Negation
		if (where.NOT) {
			return this.handleNOT(where, dataset, datasetType);
		}

		throw new InsightError("Invalid where clause");
	}

	private handleComparator(
		comparator: any,
		dataset: CourseSection[] | RoomSection[],
		datasetType: "sections" | "rooms"
	): CourseSection[] | RoomSection[] {
		const key = Object.keys(comparator)[0];
		const { [key]: condition } = comparator;
		if (Object.keys(condition).length !== 1) {
			throw new InsightError("Only one condition allowed for GT | LT | EQ");
		}

		const [field, value] = Object.entries(condition)[0];
		const fieldKey = field.split("_")[1];

		// start of code generated by ChatGPT
		const validMKeysSections = ["avg", "pass", "fail", "year", "audit"];
		const validMKeysRooms = ["lat", "lon", "seats"];

		if (datasetType === "sections" && !validMKeysSections.includes(fieldKey)) {
			throw new InsightError("Invalid mkey for comparison in sections.");
		} else if (datasetType === "rooms" && !validMKeysRooms.includes(fieldKey)) {
			throw new InsightError("Invalid mkey for comparison in rooms.");
		}
		// end of code generated by ChatGPT

		if (typeof value !== "number") {
			throw new InsightError("value should be a number");
		}

		return dataset.filter((entry) => {
			const fieldValue = entry[fieldKey as keyof typeof entry];

			if (typeof fieldValue !== "number") {
				throw new InsightError(`Field ${fieldKey} must be a number.`);
			}

			if (key === "GT") {
				return fieldValue > value;
			} else if (key === "LT") {
				return fieldValue < value;
			} else if (key === "EQ") {
				return fieldValue === value;
			}
			return false;
		}) as CourseSection[] | RoomSection[];
	}

	private handleStringComparator(
		comparator: any,
		dataset: CourseSection[] | RoomSection[],
		datasetType: "sections" | "rooms"
	): CourseSection[] | RoomSection[] {
		const { IS: condition } = comparator;
		if (Object.keys(condition).length !== 1) {
			throw new InsightError("Only one condition allowed");
		}
		const [field, pattern] = Object.entries(condition)[0];
		if (typeof pattern !== "string") {
			throw new InsightError("Wrong Is type");
		}

		const validSKeysSections = ["dept", "id", "instructor", "title", "uuid"];
		const validSKeysRooms = ["fullname", "shortname", "number", "name", "address", "type", "furniture", "href"];
		const fieldKey = field.split("_")[1];

		if (datasetType === "sections" && !validSKeysSections.includes(fieldKey)) {
			throw new InsightError("Invalid skey for sections.");
		} else if (datasetType === "rooms" && !validSKeysRooms.includes(fieldKey)) {
			throw new InsightError("Invalid skey for rooms.");
		}

		// start of code generated by ChatGPT
		if (pattern.includes("*") && !/^\*?[^*]*\*?$/.test(pattern)) {
			throw new InsightError(`Invalid wildcard placement in string '${pattern}'.`);
		}
		const regexPattern = `^${pattern.replace(/[*]/g, ".*")}$`;
		const regex = new RegExp(regexPattern);

		return dataset.filter((entry) => {
			const fieldValue = entry[fieldKey as keyof typeof entry];
			if (typeof fieldValue !== "string") {
				throw new InsightError(`Field ${fieldKey} must be a string.`);
			}
			return regex.test(fieldValue);
		}) as CourseSection[] | RoomSection[];
		// end of code generated by ChatGPT
	}

	private handleLogic(
		logicOperator: any,
		dataset: CourseSection[] | RoomSection[],
		datasetType: "sections" | "rooms"
	): CourseSection[] | RoomSection[] {
		const key = Object.keys(logicOperator)[0];
		const subFilters = logicOperator[key];

		if (!Array.isArray(subFilters) || subFilters.length === 0) {
			throw new InsightError("Logical operator must have a non-empty array");
		}
		// start of code generated by ChatGPT
		if (key === "AND") {
			return subFilters.reduce(
				(filteredDataset, filter) => this.handleWhere(filter, filteredDataset, datasetType),
				dataset
			);
		} else if (key === "OR") {
			const resultSets = subFilters.map((filter) => this.handleWhere(filter, dataset, datasetType));
			return Array.from(new Set(resultSets.flat())) as CourseSection[] | RoomSection[];
		}
		// end of code generated by ChatGPT
		throw new InsightError("Invalid logical operator");
	}

	private handleNOT(
		negation: any,
		dataset: CourseSection[] | RoomSection[],
		datasetType: "sections" | "rooms"
	): CourseSection[] | RoomSection[] {
		const subfilter = negation.NOT;
		const filteredDataset = this.handleWhere(subfilter, dataset, datasetType);

		// filter the dataset excluding the ones in the filteredDataset
		// start of code generated by ChatGPT
		if (datasetType === "sections") {
			return (dataset as CourseSection[]).filter((section) => !(filteredDataset as CourseSection[]).includes(section));
		} else {
			return (dataset as RoomSection[]).filter((section) => !(filteredDataset as RoomSection[]).includes(section));
		}
		// end of code generated by ChatGPT
	}

	private handleTransformations(transformations: any, dataset: CourseSection[] | RoomSection[]): InsightResult[] {
		const { GROUP, APPLY } = transformations;
		if (!Array.isArray(GROUP) || GROUP.length === 0) {
			throw new InsightError("GROUP must be a non-empty array.");
		}
		if (!Array.isArray(APPLY)) {
			throw new InsightError("APPLY must be an array.");
		}

		// start of code generated by ChatGPT
		const applyKeys = new Set<string>();
		for (const applyRule of APPLY) {
			const applyKey = Object.keys(applyRule)[0];

			if (applyKey.includes("_")) {
				throw new InsightError(`Invalid applyKey '${applyKey}': Cannot contain underscore.`);
			}

			if (applyKeys.has(applyKey)) {
				throw new InsightError(`Duplicate applyKey '${applyKey}' in APPLY block.`);
			}
			applyKeys.add(applyKey);
		}
		// end of code generated by ChatGPT

		for (const key of GROUP) {
			{
				if (!this.isValidKey(key)) {
					throw new InsightError("Invalid key in GROUP");
				}
			}
		}

		// Start of code generated by ChatGPT
		// Use separate maps for sections and rooms
		const groupedData = new Map<string, (RoomSection | CourseSection)[]>();

		// console.log("Dataset before grouping:", JSON.stringify(dataset, null, 2));

		for (const entry of dataset) {
			const groupValues = GROUP.map((key) => {
				const actualKey = key.split("_")[1]; // Extract the correct key
				const value = entry[actualKey as keyof typeof entry];

				if (value === undefined) {
					throw new InsightError(`Missing GROUP key '${actualKey}' in entry`);
				}
				return value;
			});

			const groupKey = groupValues.join("_");

			if (!groupedData.has(groupKey)) {
				groupedData.set(groupKey, []);
			}
			groupedData.get(groupKey)?.push(entry);
		}

		// console.log("Grouped Data:", JSON.stringify([...groupedData.entries()], null, 2));

		// end of code generated by ChatGPT

		// Process APPLY rules
		const result: InsightResult[] = [];

		for (const [, groupEntries] of groupedData.entries()) {
			const groupObject: InsightResult = {};

			// Correctly Assign GROUP Keys to the Result Object
			GROUP.forEach((key) => {
				// const value = groupKey.split("_")[index];
				// const stringFields = new Set([
				// 	"uuid", "id", "title",
				// 	"instructor", "dept", "shortname","fullname","number","name","address","furniture", "type", "href"
				// ]);
				// const fieldKey = key.includes("_") ? key.split("_")[1] : key;
				// // Ensure empty string stays an empty string
				// if (stringFields.has(fieldKey) || value === "") {
				// 	groupObject[key] = value.toString(); // This handles both strings & empty strings
				// } else {
				// 	groupObject[key] = isNaN(Number(value)) ? value : Number(value);
				// }
				// start of code generated by ChatGPT
				const fieldKey = key.includes("_") ? key.split("_")[1] : key;

				const referenceEntry = groupEntries[0]; // Pick any item in the group

				if (fieldKey in referenceEntry) {
					groupObject[key] = (referenceEntry as Record<string, any>)[fieldKey];
				}
			});

			// console.log("✅ Processed Group Object:", groupObject);
			// end of code generated by ChatGPT
			// Check for duplicate apply rules
			const ApplyKeySet = new Set<string>();
			for (const applyRule of APPLY) {
				const applyKey = Object.keys(applyRule)[0];
				if (ApplyKeySet.has(applyKey)) {
					throw new InsightError("Duplicate Apply Rules");
				}
				ApplyKeySet.add(applyKey);
			}

			// start of the code generated by chatGPT
			// Apply Each Transformation Rule
			for (const applyRule of APPLY) {
				const applyKey = Object.keys(applyRule)[0]; // Custom transformation name
				if (!applyRule[applyKey] || typeof applyRule[applyKey] !== "object") {
					throw new InsightError(`Invalid APPLY rule: '${applyKey}' is missing an operation.`);
				}
				const rule = applyRule[applyKey];
				const APPLYTOKEN = Object.keys(rule)[0];
				const KEY = rule[APPLYTOKEN];

				// ensure APPLY has condition exists
				if (!APPLYTOKEN || !KEY) {
					throw new InsightError(`Invalid APPLY rule: '${applyKey}' is missing APPLYTOKEN or KEY.`);
				}

				if (!this.isValidNumKey(KEY) && APPLYTOKEN !== "COUNT") {
					throw new InsightError(`Invalid key '${KEY}' in APPLY.`);
				}

				const fieldKey = KEY.split("_")[1] as keyof (CourseSection | RoomSection);
				// end of the code generated by chatGPT
				switch (APPLYTOKEN) {
					case "MAX":
						groupObject[applyKey] = Math.max(...groupEntries.map((entry) => entry[fieldKey] as number));
						break;
					case "MIN":
						groupObject[applyKey] = Math.min(...groupEntries.map((entry) => entry[fieldKey] as number));
						break;
					case "AVG": {
						const total = groupEntries.reduce(
							(sum, entry) => sum.add(new Decimal(entry[fieldKey] as number)),
							new Decimal(0)
						);
						groupObject[applyKey] = Number((total.toNumber() / groupEntries.length).toFixed(2));
						break;
					}
					case "SUM": {
						const total = groupEntries.reduce(
							(sum, entry) => sum.add(new Decimal(entry[fieldKey] as number)),
							new Decimal(0)
						);
						groupObject[applyKey] = Number(total.toFixed(2));
						break;
					}
					case "COUNT":
						groupObject[applyKey] = new Set(groupEntries.map((entry) => entry[fieldKey])).size;
						break;
					default:
						throw new InsightError(`Invalid APPLYTOKEN '${APPLYTOKEN}'`);
				}
			}

			result.push(groupObject);
		}

		return result;
	}

	private handleOption(option: any, dataset: InsightResult[], transformations?: any): InsightResult[] {
		const allowedKeys = ["COLUMNS", "ORDER"];
		const actualKeys = Object.keys(option);

		for (const key of actualKeys) {
			if (!allowedKeys.includes(key)) {
				throw new InsightError(`Invalid key '${key}' found in OPTIONS.`);
			}
		}
		const { COLUMNS, ORDER } = option;

		if (!Array.isArray(COLUMNS) || COLUMNS.length === 0) {
			throw new InsightError("COLUMNS must be a non-empty array.");
		}

		if (transformations) {
			const { GROUP, APPLY } = transformations;
			const groupKeys = new Set(GROUP);
			const applyKeys = new Set(APPLY.map((applyRule: any) => Object.keys(applyRule)[0]));

			for (const column of COLUMNS) {
				if (!groupKeys.has(column) && !applyKeys.has(column)) {
					throw new InsightError(`COLUMNS key '${column}' must be in GROUP or APPLY.`);
				}
			}
		}

		for (const column of COLUMNS) {
			if (typeof column !== "string") {
				throw new InsightError(`Invalid column type: '${column}'.`);
			}
			if (!this.isValidKey(column) && !dataset.some((entry) => column in entry)) {
				throw new InsightError(`Invalid column '${column}' in COLUMNS.`);
			}
		}

		if (ORDER) {
			if (typeof ORDER === "string") {
				if (!COLUMNS.includes(ORDER)) {
					throw new InsightError("ORDER must be in COLUMNS.");
				}
			} else if (typeof ORDER === "object") {
				const { dir, keys } = ORDER;
				if (!["UP", "DOWN"].includes(dir) || !Array.isArray(keys) || keys.length === 0) {
					throw new InsightError("Invalid ORDER format.");
				}
				for (const key of keys) {
					if (!COLUMNS.includes(key)) {
						throw new InsightError("ORDER keys must be in COLUMNS.");
					}
				}
			} else {
				throw new InsightError("Invalid ORDER format.");
			}
		}

		// Extract only the required COLUMNS from dataset
		const result = dataset.map((entry) => {
			const filteredEntry: InsightResult = {};
			for (const column of COLUMNS) {
				if (entry.hasOwnProperty(column)) {
					filteredEntry[column] = entry[column];
				} else {
					const parts = column.split("_");
					if (parts.length === 2) {
						const [, fieldKey] = parts;
						if (entry.hasOwnProperty(fieldKey)) {
							filteredEntry[column] = entry[fieldKey];
						}
					}
				}
			}

			return filteredEntry;
		});

		// Apply ORDER sorting
		if (ORDER) {
			if (typeof ORDER === "string") {
				result.sort((a, b) => {
					if (a[ORDER] < b[ORDER]) return -1;
					if (a[ORDER] > b[ORDER]) return 1;
					return 0;
				});
			} else {
				result.sort((a, b) => {
					for (const key of ORDER.keys) {
						if (a[key] < b[key]) return ORDER.dir === "UP" ? -1 : 1;
						if (a[key] > b[key]) return ORDER.dir === "UP" ? 1 : -1;
					}
					return 0;
				});
			}
		}

		return result;
	}

	// start of code generated by ChatGPT
	private isValidKey(key: string): boolean {
		const validFields = ["dept", "id", "instructor", "title", "uuid", "avg", "pass", "fail", "audit", "year"];

		const validRoomFields = [
			"fullname",
			"shortname",
			"number",
			"name",
			"address",
			"lat",
			"lon",
			"seats",
			"type",
			"furniture",
			"href",
		];

		// Check if the key is in the form <dataset_id>_<field>
		const parts = key.split("_");
		if (parts.length !== 2) {
			return false;
		}

		const [datasetId, field] = parts;
		return datasetId.length > 0 && (validFields.includes(field) || validRoomFields.includes(field));
	}
	// end of code generated by ChatGPT

	private isValidNumKey(key: string): boolean {
		const validSectionNumFields = ["avg", "pass", "fail", "audit", "year"];

		const validRoomNumFields = ["lat", "lon", "seats"];

		// Check if the key is in the form <dataset_id>_<field>
		const parts = key.split("_");
		if (parts.length !== 2) {
			return false;
		}

		const [datasetId, field] = parts;
		return datasetId.length > 0 && (validSectionNumFields.includes(field) || validRoomNumFields.includes(field));
	}

	public async performQuery(query: unknown): Promise<InsightResult[]> {
		// check if the query type is valid, otherwise throw an error
		await this.cashDone;
		if (typeof query !== "object" || query === null) {
			throw new InsightError("Query must be an Object");
		}

		const allowedKeys = ["WHERE", "OPTIONS", "TRANSFORMATIONS"];
		const actualKeys = Object.keys(query);

		for (const key of actualKeys) {
			if (!allowedKeys.includes(key)) {
				throw new InsightError(`Invalid key '${key}' found in OPTIONS.`);
			}
		}
		// start of code generated by ChatGPT
		// This part break down the query into two structures where and option
		const { WHERE, OPTIONS, TRANSFORMATIONS } = query as any;
		if (!WHERE || !OPTIONS) {
			throw new InsightError("Query must have WHERE and OPTIONS.");
		}
		// end of code generated by ChatGPT

		const dataset = (await this.getDatasetFromQuery(query)) as CourseSection[] | RoomSection[];

		// start of the code generated by ChatGPT
		const datasetType = dataset.length > 0 ? ((dataset[0] as any).avg !== undefined ? "sections" : "rooms") : null;
		// end of the code generated by ChatGPT

		if (!datasetType) {
			throw new InsightError("Invalid Dataset Type");
		}

		let filteredDataset: CourseSection[] | RoomSection[] | InsightResult[] = this.handleWhere(
			WHERE,
			dataset,
			datasetType
		);

		// Apply transformations (if present)
		if (TRANSFORMATIONS) {
			filteredDataset = this.handleTransformations(TRANSFORMATIONS, filteredDataset);
		}
		// console.log("result", JSON.stringify(filteredDataset, null, 2));
		// start of code generated by ChatGPT
		// Ensure filteredDataset is always InsightResult[] before passing to handleOptions
		const normalizedDataset: InsightResult[] =
			Array.isArray(filteredDataset) && filteredDataset.length > 0
				? (filteredDataset as InsightResult[])
				: filteredDataset.map((entry) => {
						const resultEntry: InsightResult = {};
						Object.keys(entry).forEach((key) => {
							resultEntry[key] = (entry as any)[key];
						});
						return resultEntry;
					});
		// console.log("result", JSON.stringify(normalizedDataset, null, 2));
		// end of code generated by ChatGPT
		const result = this.handleOption(OPTIONS, normalizedDataset, TRANSFORMATIONS);
		// console.log("result", JSON.stringify(result, null, 2));
		if (result.length > 5000) {
			throw new ResultTooLargeError("Query exceed 5000");
		}
		return result;
	}

	private async getDatasetFromQuery(query: any): Promise<(CourseSection | RoomSection)[]> {
		// Extract dataset id from query and find it in cached datasets.
		const columns = query.OPTIONS?.COLUMNS ?? [];
		const datasetId = columns[0]?.split("_")[0];

		if (!datasetId) {
			throw new InsightError("Invalid or missing dataset ID in query.");
		}
		// start of code generated by ChatGPT
		const datasetFilePath = `data/${datasetId}.json`;

		try {
			// Check if the dataset file exists and read it asynchronously
			await fs.access(datasetFilePath);
			const dataset = await fs.readJSON(datasetFilePath);

			// check if the dataset type is section or room
			if (dataset.kind === InsightDatasetKind.Sections) {
				return dataset.courseSections;
			} else {
				return dataset.allRooms;
			}
		} catch (err) {
			throw new InsightError(String(err));
		}
		// end of code generated by ChatGPT
	}

	public async listDatasets(): Promise<InsightDataset[]> {
		await this.cashDone;
		// list all datasets
		return this.datasets;
	}
}
